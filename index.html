<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>P2P Chat avec PeerJS</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <div class="content">
      <h1>P2P Chat</h1>

      <div id="userId">
        <h2>My User ID:</h2>
        <p id="my-id"></p>
      </div>

      <hr />

      <label>Choose your pseudo: </label><input type="text" id="pseudo" placeholder="Pseudo *" required />

      <hr />

      <h3>Rooms</h3>
      <div id="room-list">Loading rooms...</div>
      <button class="validation" onclick="createRoom()">Generate a room</button>

      <hr />

      <h3>Live Chat</h3>
      <div id="messages"></div>

      <h3>Send Room Message</h3>
      <div id="chat-form">
      <div class="inputs">
        <input type="text" id="msg" placeholder="Message *" required />
      </div>
      <button class="validation" id="send-btn">Send</button>
      <button class="validation" id="send-img-btn">ðŸ“· Image</button>
      <input
        type="file"
        id="img-input"
        accept="image/*"
        style="display: none"
      />
      </div>

      <h3>Send Private Message</h3>
      <div class="pm-row">
        <input type="text" id="pm-user-id" placeholder="User ID *" />
        <button class="validation" onclick="toggleBlockUser()">Block / Unblock</button>
      </div>
      <input type="text" id="pm-msg" placeholder="Message *" />
      <button class="validation" onclick="sendPM()">Send PM</button>
      <button class="validation" onclick="sendPImages()">ðŸ“· Image</button>
    </div>

    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script>
      const peer = new Peer({ host: "localhost", port: 9000, path: "/peerjs" });
      let isHost = false;
      let conn = null;
      let members = {};

      peer.on("open", (id) => {
        document.getElementById("my-id").textContent = id;
        listRooms();
        setInterval(listRooms, 10000);
      });

      async function createRoom() {
        isHost = true;
        const roomName = prompt("Room name ?");
        if (!roomName) return;
        addMessage("Room created! Share this ID: " + peer.id);

        await fetch("http://localhost:3000/rooms", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id: peer.id, name: roomName }),
        });

        listRooms();
      }

      async function listRooms() {
        const res = await fetch("http://localhost:3000/rooms");
        const rooms = await res.json();
        const roomListDiv = document.getElementById("room-list");
        roomListDiv.innerHTML = "";

        if (rooms.length === 0) {
          roomListDiv.innerHTML = "<p>No active rooms</p>";
          return;
        }

        rooms.forEach((room) => {
          const btn = document.createElement("button");
          btn.textContent = room.name + " (" + room.id + ")";
          btn.onclick = () => joinRoom(room.id);
          roomListDiv.appendChild(btn);
        });
      }

      function joinRoom(id) {
        if (!id) return;
        conn = peer.connect(id);
        setupClient(conn);
      }

      peer.on("connection", (c) => {
        if (!isHost) return;
        members[c.peer] = c;
        addMessage("User joined: " + c.peer);
        setupHost(c);
      });

      function setupHost(c) {
        c.on("data", (data) => {
          if (!data) return;

          if (data.type === "image") {
            addImage(data.pseudo, data.message, data.data);
          } else {
            addMessage(data.pseudo + " : " + data.message);
          }

          for (let id in members) {
            if (id !== c.peer) members[id].send(data);
          }
        });

        c.on("close", () => {
          delete members[c.peer];
          addMessage("User left: " + c.peer);
        });
      }

      function setupClient(c) {
        c.on("open", () => {
            console.log("Connected to host", c.peer);
            addMessage("Connected to the room!")
        });
        c.on("data", (data) => {
          if (!data) return;
          if (data.type === "image") {
            addImage(data.pseudo, data.message, data.data);
          } else {
            addMessage(data.pseudo + " : " + data.message);
          }
        });
        c.on("close", () => addMessage("Disconnected from the room"));
      }

      document.getElementById("send-btn").onclick = () => {
        const pseudo = document.getElementById("pseudo").value.trim();
        const msg = document.getElementById("msg").value.trim();
        if (!pseudo || !msg) {
          alert("Pseudo and message are required");
          return;
        }

        const data = { type: "text", pseudo, message: msg };
        if (isHost) {
          for (let id in members) members[id].send(data);
          addMessage(pseudo + " : " + msg);
        } else if (conn) {
          conn.send(data);
          addMessage(pseudo + " : " + msg);
        }

        document.getElementById("msg").value = "";
      };

      const imgInput = document.getElementById("img-input");
      document.getElementById("send-img-btn").onclick = () => {
        const pseudo = document.getElementById("pseudo").value.trim();
        if (!pseudo) {
          alert("Pseudo is required");
          return;
        }
        imgInput.click();
      };

      imgInput.onchange = () => {
        const file = imgInput.files[0];
        if (!file) return;

        const pseudo = document.getElementById("pseudo").value.trim();
        const message = document.getElementById("msg").value.trim();

        const reader = new FileReader();
        reader.onload = () => {
          const data = { type: "image", pseudo, message, data: reader.result };
          if (isHost) {
            for (let id in members) members[id].send(data);
            addImage(pseudo, message, reader.result);
          } else if (conn) {
            conn.send(data);
            addImage(pseudo, message, reader.result);
          }

          imgInput.value = "";
          document.getElementById("msg").value = "";
        };
        reader.readAsDataURL(file);
      };

      function addMessage(text) {
        const div = document.getElementById("messages");
        div.innerHTML += text + "<br>";
        div.scrollTop = div.scrollHeight;
      }

      function addImage(pseudo, message, base64) {
        const div = document.getElementById("messages");
        const container = document.createElement("div");
        container.style.marginBottom = "10px";
        if (message) container.innerHTML = pseudo + " : " + message + "<br>";
        else container.innerHTML = pseudo + " :<br>";

        const img = document.createElement("img");
        img.src = base64;
        container.appendChild(img);
        div.appendChild(container);
        div.scrollTop = div.scrollHeight;
      }

      let pmConnections = {};
      let blockedUsers = new Set();

      function sendPM() {
        const pseudo = document.getElementById("pseudo").value.trim();
        const targetId = document.getElementById("pm-user-id").value.trim();
        if (blockedUsers.has(targetId)) {
          addMessage("[System] Impossible dâ€™envoyer : utilisateur bloquÃ©.");
          return;
        }
        const message = document.getElementById("pm-msg").value.trim();

        if (!pseudo || !targetId || !message) {
          alert("Pseudo, User ID et message sont obligatoires");
          return;
        }

        let pmConn = pmConnections[targetId];

        if (!pmConn) {
          pmConn = peer.connect(targetId);
          pmConnections[targetId] = pmConn;

          pmConn.on("open", () => {
            pmConn.send({ type: "pm", pseudo, message });
            addMessage("[Private] " + pseudo + " : " + message);
          });

          pmConn.on("data", (data) => {
            if (data.type === "pm") {
              addMessage("[Private] " + data.pseudo + " : " + data.message);
            }
          });

          pmConn.on("close", () => {
            delete pmConnections[targetId];
          });

        } else {
          pmConn.send({ type: "pm", pseudo, message });
          addMessage("[Private] " + pseudo + " : " + message);
        }

        document.getElementById("pm-msg").value = "";
      }

      peer.on("connection", (c) => {
        c.on("data", (data) => {
          if (blockedUsers.has(c.peer)) return;
          if (data.type === "pm") {
            addMessage("[Private] " + data.pseudo + " : " + data.message);
          }
          if (data.type === "pm-image") {
            addPrivateImage(data.pseudo, data.message, data.data);
          }
        });
      });

      function sendPImages() {
        const pseudo = document.getElementById("pseudo").value.trim();
        const targetId = document.getElementById("pm-user-id").value.trim();
        const message = document.getElementById("pm-msg").value.trim();

        if (!pseudo || !targetId) {
          alert("Pseudo et User ID sont obligatoires");
          return;
        }

        const fileInput = document.createElement("input");
        fileInput.type = "file";
        fileInput.accept = "image/*";

        fileInput.onchange = () => {
          const file = fileInput.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = () => {
            const base64 = reader.result;

            const data = {
              type: "pm-image",
              pseudo,
              message,
              data: base64
            };

            let pmConn = pmConnections[targetId];

            if (!pmConn) {
              pmConn = peer.connect(targetId);
              pmConnections[targetId] = pmConn;

              pmConn.on("open", () => {
                pmConn.send(data);
                addPrivateImage(pseudo, message, base64);
              });

              pmConn.on("data", (data) => {
                if (data.type === "pm-image") {
                  addPrivateImage(data.pseudo, data.message, data.data);
                }
              });

              pmConn.on("close", () => {
                delete pmConnections[targetId];
              });

            } else {
              pmConn.send(data);
              addPrivateImage(pseudo, message, base64);
            }
          };

          reader.readAsDataURL(file);
        };

        fileInput.click();
      }

      function toggleBlockUser() {
        const targetId = document.getElementById("pm-user-id").value.trim();
        if (!targetId) return alert("User ID manquant");

        if (blockedUsers.has(targetId)) {
          blockedUsers.delete(targetId);
          addMessage("[System] " + targetId + " dÃ©bloquÃ©");
        } else {
          blockedUsers.add(targetId);
          addMessage("[System] " + targetId + " bloquÃ©");
        }
      }

      function addPrivateImage(pseudo, message, base64) {
        const div = document.getElementById("messages");

        const container = document.createElement("div");
        container.style.marginBottom = "10px";

        if (message)
          container.innerHTML = "[Private] " + pseudo + " : " + message + "<br>";
        else
          container.innerHTML = "[Private] " + pseudo + " :<br>";

        const img = document.createElement("img");
        img.src = base64;
        container.appendChild(img);

        div.appendChild(container);
        div.scrollTop = div.scrollHeight;
      }
    </script>
  </body>
</html>